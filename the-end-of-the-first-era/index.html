<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Along the Watchtower">
    
    <link rel="shortcut icon" href="https://thedevtop.github.io/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <link rel="canonical" href="https://thedevtop.github.io/the-end-of-the-first-era/" />
    <title>The end of the first era</title>
</head>
<body><header id="banner">
    <h2><a href="https://thedevtop.github.io/">TheDevtop</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/" title="posts">posts</a>
            </li><li>
                <a href="/about/" title="about">about</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>The end of the first era</h1>
        <div>
                <time>June 14, 2024</time>
            </div>
    </header><p>In this article I am going to tell you about my reevaluation of my mental model of IT.
My old mental model was the UNIX filesystem, in this model everything in IT is explained with reading and writing files.
So the execution of a program is like the reading of a file from the filesystem into a memory file (a page), after which you execute it (essentially by reading from that memory file).
Likewise the communication between client and server is like the reading and writing to a file that happens to be (partially) located on a different machine.</p>
<p>This model has been a real help in the first part of my career; but this last semester has also shown that there are limits to what can be explored/explained with the UNIX model.
It&rsquo;s not the case that I am going to discard UNIX, on the contrary; I am going to cement it as the canonical Operating System.
But I am going to discard the UNIX model as my central theory of computing.</p>
<p><em>Unix is dead, God bless Unix!</em></p>
<h3 id="the-secondsymbolic-era">The second/symbolic era</h3>
<p>As mentioned in the <a href="https://thedevtop.github.io/software-defined-automatic-calculator/">SDAC</a> article, I wanted to learn Lisp.
So a few months ago I bought the <a href="https://web.mit.edu/6.001/6.037/sicp.pdf">SICP book</a> and learned Scheme (a minimal functional Lisp).
Within the first two chapters I fell in love with the notion of symbolic programming.
Specifically the notion that if everything is a symbolic expression, the difference between &ldquo;code&rdquo; and &ldquo;data&rdquo; is trivial.
Meaning that you can execute &ldquo;data&rdquo;, and compute on &ldquo;code&rdquo;.
And because I was in dire need of a theory of computing, I adopted it.</p>
<p>For reference I will put my paraphrase of the statement here:</p>
<blockquote>
<p>Any program can be correctly designed by the carefull study of computational processes, whether synthesized from the natural world or not.
The notation of computational processes are symbols, these symbols can be used actively (as code) and passively (as data); but this distinction is not inherent.
The organization of symbols into programs can be done in three ways:</p>
<p>Primitive expressions; these represent the simplest symbols of the process.</p>
<p>Means of combination; compound symbols are built from simpler ones.</p>
<p>Means of abstraction; compound symbols can be named and manipulated as symbols themselves.</p>
</blockquote>
<p>After the adoption I worked/am-working on several things, which I can&rsquo;t disclose because I have a contract.
Nonetheless I noticed that concept like higher-order and recursive functions make more sense when looking at it trough the lens of symbolic programming.</p>
</article>

        </main><footer id="footer">
    Copyright Â© 2023 Thijs Haker
</footer>
</body>
</html>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tags on TheDevtop</title>
    <link>https://thedevtop.github.io/tags/</link>
    <description>Recent content in Tags on TheDevtop</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://thedevtop.github.io/tags/index.xml" rel="self" type="application/rss+xml" />
    
    
    
    <item>
      <title>The compiler is right</title>
      <link>https://thedevtop.github.io/the-compiler-is-right/</link>
      <pubDate>Tue, 03 Oct 2023 22:21:54 +0200</pubDate>
      
      <guid>https://thedevtop.github.io/the-compiler-is-right/</guid>
      <description>&lt;p&gt;Last summer was quite special, for me it was the summer of Rust.
I started at &amp;ldquo;Hello, world!&amp;rdquo; and ended with multi-threaded Map/Filter/Reduce functions, all while handling errors &lt;strong&gt;correctly&lt;/strong&gt;.
The Rust compiler is a real help with that, and it&amp;rsquo;s because of its strictness that it can produce such helpfull messages.&lt;/p&gt;
&lt;p&gt;After the summer break I found out that: Not only did Rust grinding improve my general (Go/C) programming skills, it also improved my taste for good error messaging.
If C thaught me how the machine worked, then Rust taught me what the machine could do.
There is a slight irony there because even tough Rust and C are both seen as systems languages, in personality they are very much the opposite.&lt;/p&gt;
&lt;h3 id=&#34;colliding-characters&#34;&gt;Colliding characters&lt;/h3&gt;
&lt;p&gt;The C programming language is in spirit the same as its elder brother: The UNIX operating system.
Both view the universe trough a single lens.
In UNIX, everything is a file descriptor; in C, everything is a pointer.
They allow you great flexibility in how to interact with that universe, sometimes even to a ridiculus extend.
Herein lies the problem, you can use that flexibility to break the universe.&lt;/p&gt;
&lt;p&gt;Enter Rust, its lens is like C (everything is a pointer).
But its argument is rather different: The universe is presumed fragile, thus we will only allow interaction in a &lt;strong&gt;correct&lt;/strong&gt; manner.
Correct meaning the disambiguation of memory/pointers.&lt;/p&gt;
&lt;p&gt;Programmers don&amp;rsquo;t think about this too often, but these arguments are interwoven with the behaviour of the compilers.
Which is why Rust won&amp;rsquo;t compile your code and give you very explicit errors; and why C will compile almost any crazy contraption you will come up with.&lt;/p&gt;
&lt;p&gt;But here is the kicker, you can learn from both worlds.&lt;/p&gt;
&lt;h3 id=&#34;the-better-programmer&#34;&gt;The better programmer&lt;/h3&gt;
&lt;p&gt;A good programmer can break problems down in small pieces (top-down), and build solutions from simple primitives (bottom-up).
A better programmer also knows (like the good blacksmith), that steel can be used to both build railroads and swords.
Sometimes you will need to probe into the soul of the machine;
learning the lessons from Rust and applying them as practice into C codebases has made me a better programmer, and it will make you.&lt;/p&gt;
&lt;p&gt;Whether your code will compile or not, the compiler is right.&lt;/p&gt;
&lt;h3 id=&#34;sources&#34;&gt;Sources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.nl/-/en/Steve-Klabnik/dp/1718503105&#34;&gt;Book: The Rust Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628&#34;&gt;Book: The C Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X&#34;&gt;Book: The UNIX Programming Environment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>UVM: A secret love letter</title>
      <link>https://thedevtop.github.io/uvm-a-secret-love-letter/</link>
      <pubDate>Tue, 03 Oct 2023 19:25:35 +0200</pubDate>
      
      <guid>https://thedevtop.github.io/uvm-a-secret-love-letter/</guid>
      <description>&lt;p&gt;Recently, I had some DIMM corruption, which led me to decommission one of my machines.
The hole situation got me thinking about the fragility of software and how not even the most elegant abstraction, can save you from the grim reality of hardware failure.
It also happens to be a good reason to talk about one of my favorite pieces of software: &lt;a href=&#34;https://www.usenix.org/legacy/event/usenix99/full_papers/cranor/cranor.pdf&#34;&gt;The UVM Virtual Memory System&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;let-there-be-light&#34;&gt;Let there be light&lt;/h3&gt;
&lt;p&gt;UVM is the virtual memory subsystem used in the kernels of &lt;a href=&#34;https://www.openbsd.org/&#34;&gt;OpenBSD&lt;/a&gt; and &lt;a href=&#34;https://www.netbsd.org/&#34;&gt;NetBSD&lt;/a&gt;.
It was written to replace the old (4.4BSD) virtual memory subsystem, which was a modified version of the one found in Carnegie Mellon&amp;rsquo;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Mach_(kernel)&#34;&gt;Mach&lt;/a&gt; microkernel.
The reason for replacement was straightforward: Poor performance, complex data structures, and poor documentation.
Which is quite funny because today (2023) the best documentation I could find about the Mach VM comes from &lt;a href=&#34;https://developer.apple.com/documentation/kernel/mach/vm&#34;&gt;Apple&lt;/a&gt; and &lt;a href=&#34;http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/&#34;&gt;MIT&lt;/a&gt;, not from Carnegie Mellon.&lt;/p&gt;
&lt;p&gt;The reason for UVM is the classic triad: Simplicity, performance, and maintainability.&lt;/p&gt;
&lt;h3 id=&#34;masters-of-architecture&#34;&gt;Masters of architecture&lt;/h3&gt;
&lt;p&gt;Having a great VM implementation is one thing, but having a great paper to companion it is something else entirely.
With UVM, Cranor and Parulkar give us both.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://thedevtop.github.io/uvm_arch.png&#34; alt=&#34;uvm_arch&#34;&gt;
The architecture is easy to understand.
The &lt;em&gt;vmspace&lt;/em&gt; structure contains pointers to a processâ€™s &lt;em&gt;pmap&lt;/em&gt; and &lt;em&gt;memory map&lt;/em&gt; structures, it also contains some statistics.
The &lt;em&gt;pmap&lt;/em&gt; is the machine-dependent structure, while the &lt;em&gt;memory map&lt;/em&gt; is the machine-independent structure that holds the memory objects.&lt;/p&gt;
&lt;p&gt;Some observations: The various segments (text/data/stack) are seperate objects, which is beneficial for security.
The objects can be of many types, and backed by many &lt;em&gt;pagers&lt;/em&gt;.
The important thing here, is that these types and pagers can be implemented by &lt;strong&gt;other&lt;/strong&gt; kernel subsystems (which I think is so cool).
Finally, UVM allows for anonymous mapping, which is usefull if you have two processes that map the same object (like the text segment of &lt;code&gt;/bin/sh&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&#34;the-sound-of-memory&#34;&gt;The sound of memory&lt;/h3&gt;
&lt;p&gt;Managing (virtual) memory is not easy, and implementing a good VM is definitely not easy. But UVM manages to do it while retaining flexibility and an astonishingly simple architecture.&lt;/p&gt;
&lt;p&gt;Simplicity while managing &lt;a href=&#34;https://en.wikipedia.org/wiki/Kernel_(operating_system)&#34;&gt;Heaven and Earth&lt;/a&gt;, is why UVM remains my favorite piece of software.&lt;/p&gt;
&lt;h3 id=&#34;sources&#34;&gt;Sources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/NetBSD/src/tree/trunk/sys/uvm&#34;&gt;NetBSD Kernel/UVM (Source)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openbsd/src/tree/master/sys/uvm&#34;&gt;OpenBSD Kernel/UVM (Source)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openmach/openmach/tree/master/kernel/vm&#34;&gt;OpenMach VM (Source)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.usenix.org/legacy/events/usenix2000/freenix/full_papers/silvers/silvers.pdf&#34;&gt;Unified Buffer Cache (Paper)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    
  </channel>
</rss>

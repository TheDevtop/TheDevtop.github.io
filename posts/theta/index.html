<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://thedevtop.github.io//favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://thedevtop.github.io//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://thedevtop.github.io//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://thedevtop.github.io//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://thedevtop.github.io//apple-touch-icon.png><meta name=description content><title>Theta | DEVTOP</title><link rel=canonical href=https://thedevtop.github.io/posts/theta/><meta property="og:url" content="https://thedevtop.github.io/posts/theta/"><meta property="og:site_name" content="DEVTOP"><meta property="og:title" content="Theta"><meta property="og:description" content="What is computing; if not a space where mathematics, logic, and philosophy can elegantly be expressed?
Introduction # While learning LISP and reading SICP I became enamoured with the evaluator. The evaluator is (usually) a function or small program that deconstructs a symbolic expression and tries to get a value out of it. If the expression is a value, it simply returns that value; but if part of the expression is evaluable or executable in itself, it will evaluate that part and apply the rest of the expression to it. Which means that if you have a way of defining evaluable an expression (let’s call it a lambda); you can define and evaluate any computable expression!"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-07T16:55:18+02:00"><meta property="article:modified_time" content="2025-05-07T16:55:18+02:00"><link rel=stylesheet href=/assets/combined.min.76ae4862c0255898090a8ee2c877f67dfb7e7a1f308feca44ea17713ee4736cd.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://thedevtop.github.io/>DEVTOP</a></h1><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/posts>/posts</a></p></div></div></header><main class=main><div><div class=single-intro-container><h1 class=single-title>Theta</h1><p class=single-readtime><time datetime=2025-05-07T16:55:18+02:00>May 7, 2025</time></p></div><div class=single-content><blockquote><p>What is computing; if not a space where mathematics, logic, and philosophy can elegantly be expressed?</p></blockquote><h3 class=heading id=introduction>Introduction
<a href=#introduction>#</a></h3><p>While learning LISP and reading <a href=https://web.mit.edu/6.001/6.037/sicp.pdf>SICP</a> I became enamoured with the evaluator.
The evaluator is (usually) a function or small program that deconstructs a symbolic expression and tries to get a value out of it.
If the expression is a value, it simply returns that value;
but if part of the expression is <em>evaluable</em> or <em>executable</em> in itself, it will evaluate that part and apply the rest of the expression to it.
Which means that if you have a way of defining evaluable an expression (let&rsquo;s call it a <a href=https://en.wikipedia.org/wiki/Lambda_calculus>lambda</a>);
you can define and evaluate <strong>any</strong> computable expression!</p><p>This left me wanting to write one myself.</p><p><strong><a href=https://github.com/TheDevtop/theta-go>Repository</a></strong></p><h3 class=heading id=θ-list-processor>(Θ list processor)
<a href=#%ce%b8-list-processor>#</a></h3><p><strong>Theta</strong> is a list processor, inspired by Clojure and Elisp, written in Go.</p><h4 class=heading id=on-building-theta>On building Theta
<a href=#on-building-theta>#</a></h4><p>To build Theta, execute: <code>$ make build</code></p><p>This should produce the <code>./bin/theta</code> and <code>./bin/threpl</code> executables.</p><h4 class=heading id=on-installing-theta>On installing Theta
<a href=#on-installing-theta>#</a></h4><p>To install Theta, execute: <code>$ cp ./bin/* /usr/local/bin/</code></p><h4 class=heading id=on-using-theta>On using Theta
<a href=#on-using-theta>#</a></h4><p>Read the <a href=doc/thenual.md>Thenual</a>.</p><h4 class=heading id=on-naming-theta>On naming Theta
<a href=#on-naming-theta>#</a></h4><p>The reasons for the name are twofold:</p><p>There are many computer science concepts referencing greek letters:</p><ul><li>Raspberry <strong>Pi</strong></li><li><strong>Lambda</strong> calculus</li><li><strong>Zeta</strong> Lisp</li><li>The Emacs logo (<strong>ξ</strong>)</li></ul><p>My initials are <strong>TH</strong>, which is the loose phonetic transcription of the letter <strong>Θ</strong>.</p></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/posts/literature/>Literature list</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/posts/quicktable/>Quicktable</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Written by Thijs Haker, powered by UNIX.</p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>
<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://thedevtop.github.io//favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://thedevtop.github.io//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://thedevtop.github.io//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://thedevtop.github.io//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://thedevtop.github.io//apple-touch-icon.png><meta name=description content><title>Quicktable | DEVTOP</title><link rel=canonical href=https://thedevtop.github.io/posts/quicktable/><meta property="og:url" content="https://thedevtop.github.io/posts/quicktable/"><meta property="og:site_name" content="DEVTOP"><meta property="og:title" content="Quicktable"><meta property="og:description" content="Now all in unison: foo:bar:baz:bar:foo
Introduction # Being inspired by Google Bigtable left me wanting to write my own wide-column database. Now I know that Bigtable is not “just” a wide-column database, it is a highly-scalable, distributed (CP) database. Lucky for me, I don’t need “highly-scalable” or “distributed”, I have Kubernetes for that. What I really want is a database with a nice API, none of that SQL and weird database connector stuff. Just keys and values over JSON/HTTP. I want Bigtable but quick, local, and small."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-31T14:26:39+02:00"><meta property="article:modified_time" content="2025-05-31T14:26:39+02:00"><link rel=stylesheet href=/assets/combined.min.76ae4862c0255898090a8ee2c877f67dfb7e7a1f308feca44ea17713ee4736cd.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://thedevtop.github.io/>DEVTOP</a></h1><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/posts>/posts</a></p></div></div></header><main class=main><div><div class=single-intro-container><h1 class=single-title>Quicktable</h1><p class=single-readtime><time datetime=2025-05-31T14:26:39+02:00>May 31, 2025</time></p></div><div class=single-content><blockquote><p>Now all in unison: <code>foo:bar:baz:bar:foo</code></p></blockquote><h3 class=heading id=introduction>Introduction
<a href=#introduction>#</a></h3><p>Being inspired by <a href=https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf>Google Bigtable</a> left me wanting to write my own wide-column database.
Now I know that Bigtable is not &ldquo;just&rdquo; a wide-column database, it is a highly-scalable, distributed (CP) database.
Lucky for me, I don&rsquo;t need &ldquo;highly-scalable&rdquo; or &ldquo;distributed&rdquo;, I have Kubernetes for that.
What I <em>really</em> want is a database with a nice API, none of that SQL and weird database connector stuff.
Just keys and values over JSON/HTTP.
I want Bigtable but quick, local, and small.</p><p>So I made one.</p><h3 class=heading id=quicktable>Quicktable
<a href=#quicktable>#</a></h3><p><strong><a href=https://github.com/TheDevtop/quicktable>Repository</a></strong></p><p>Quicktable is at its core a wrapper around <a href=https://docs.hypermode.com/badger/overview>Badger</a>, which is a key/value store based on a <a href=https://en.wikipedia.org/wiki/Log-structured_merge-tree>LSM tree</a>.
In line with my previous projects; everything is a list of strings.
They can be read from, written to, reduced to a single value, and expanded back to multiple ones.
From the concept of lists of strings I extrapolated other types:</p><ul><li>Keyspaces and valuesets: <code>["foo", "bar", "baz"]</code></li><li>Key: <code>"foo:bar:baz"</code></li><li>Value: <code>"Hello, world!"</code></li></ul><p>Because they are all essentially the same &ldquo;thing&rdquo; I can use them interchangeably.
So a keyspace can be reduced to a key (<code>["hotel", "trivago"]</code> -> <code>"hotel:trivago"</code>), and vice versa.
Values can become keys, and keys can become values.
You can also build hierarchies of keys, simulating more traditional databases.</p><p>For more practical details you can read the <a href=https://github.com/TheDevtop/quicktable/blob/main/docs/apidoc.md>API document</a>.</p><h3 class=heading id=implementation>Implementation
<a href=#implementation>#</a></h3><p>As of the date of publishing, the version of Quicktable 0.5; and the project is still very young.
I have implemented most of the so-called <a href=https://en.wikipedia.org/wiki/Create,_read,_update_and_delete>CRUD</a> functionality and more.
I also have deployment options for Docker, Kubernetes, Nomad, or as a Systemd service.
All of which have been running stable and tested.</p><p>In the future I am planning a Go <a href=https://github.com/TheDevtop/quicktable/tree/main/pkg/client>client package</a>, with you can use Quicktable programmatically.</p></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/posts/theta/>Theta</a></div></div></div><div class=single-pagination-next></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Written by Thijs Haker, powered by UNIX.</p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>